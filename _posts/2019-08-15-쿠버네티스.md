---
layout: post
title: 쿠버네티스란 ?
subtitle: 
gh-repo: 
gh-badge: [star, fork, follow]
tags: [Web]
categories : [Other]
---

####

쿠버네티스는 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼이다.  
컨테이너 플랫폼, 마이크로서비스 플랫폼

---

#### 기능

서비스 디스커버리와 로드 밸런싱 
쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.

스토리지 오케스트레이션 
쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.

자동화된 롤아웃과 롤백 
쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.

자동화된 빈 패킹(bin packing) 
쿠버네티스를 사용하면 각 컨테이너에 필요한 CPU 및 메모리 (RAM)의 양을 지정할 수 있다. 컨테이너에 자원 요청이 지정되면 쿠버네티스는 컨테이너에 대한 자원을 관리하기 위해 더 나은 결정을 내릴 수 있다.

자동화된 복구(self-healing) 
쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, ‘사용자 정의 상태 검사’에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.

시크릿과 구성 관리 
쿠버네티스를 사용하면 암호, OAuth 토큰 및 ssh 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 비밀을 노출하지 않고도 비밀 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.

---

쿠버네티스의 장점은 자동화된 복구기능을 이용해 무중단 서비스가 가능하고 다른업체의 벤더를 이용할떄 생기는 벤더락인에 종속되지않아 클라우드 환경을 변경하기 쉽다고 한다.

그냥 어떤 기능만 있는가 궁금해서 찾아봤는데 상당히 많은 기능이 있는 것 같다.

---

기본 구성

도커에 컨테이너 하나하나 관리가 없다. 이때 쿠버네티스같은 컨테이너기반 오케스트라를 쓰게 된다.
쿠버네티스는 마스터, 노드로 구성된다.
마스터는 클러스터 관리(노드관리), 노드는 물리PC(가상머신도O)이고 클러스터 내 워커머신이다.

마스터에는 API 서버, 프록시 등이 설치된다. 요청이 마스터를 통해 들어간다.
이때문에 마스터의 스펙은 네트워크가 빵빵해야 하지않을까 생각된다.
마스터는 api, etcd(설정정보, etcd. etcd는 분산 key-value store)

	- 마스터와 클러스터간의 Kubelet, apiserver/ 클->마 -> apiserver
	- 오브젝트 - 쿠버네티스의 기본구성단위(스펙은 Yaml, Json으로 정의된다)
	- 컨트롤러 - 오브젝트를 관리한다.(Replication controller, deployment등)
	- Pod- 기본 배포단위, 하나의 pod에 여러 컨테이너를 포함한다.
	- Volume - 디스크영역, pod에 연결된 스토리지이다.
	- Service - 로드밸런서, 서비스 디스커버리, 포트포워딩을 한다.
	- NameSpace - 논리적인 분리단위 이다.

---

#### Controller 

	- Replication controller - 지정된 숫자의 pod을 관리한다. 
Replica(개수), selector(label- 이름을 정의 이름에 해당하는 많은 pod를 실행), template(포트등을 정의한다)
	- // set - controller와 일, selector의 항목이 더 다양하다.
	- Daemon Set - 서버의 모니터링, 로그 수집같이 한가지가 필요한때 사용, 원하는 곳에 1개만 배포
	- Job - 한번만 실행되는 작업, 작업실패 시 다시 실행하거나(restart정책)하는 등의 설정 가능
	- Deployment - RC,RS에 배포기능 추가(자동), 히스토리가 남아 언제든지 롤백가능
		   - 예로 3개의 pod 생성 후, 정상인지 확인하고, 로드밸런스 전환 후 , 전에 것 삭제
		
---

#### Volume

	- emptyDir - 해당하는 pod내에서만 공유되는 스토리지
	- hostPath - 노드의 로컬 disk, pod에 mount된다. 도커의 volume과 비슷, 노드에 종속되고 노드가 죽으면 끝이다. Pod간의 교류용이다.
	- persistentVolume - 실제 물리적 디스크(동적디스크)
	- // clain - 사용자가 생성하는 pv와 pod를 연결한다. 전체 클러스터에서 연겨러, pv를 미릴 만들어두면 pvc에 해당하는 것만 적으면 사용 가능

-그림-

---

#### Service 

	- Cluter Ip - 기본적으로 가지게 되는 Ip
	- Load balancer - IP를 하나 만들어 할당된다.
	- Node ip - 노드의 Ip로 pod 포트포워딩 된다.
	- Extand name - pod에서 외부 서비스를 호출한다(외부 ip를 생성해 그 ip로 호출한다)

-그림-

--- 

장점 
	- Auto Scaling, 로드밸런싱, 죽었을때 살려줌

단점
	- Yaml이 어렵다

생각해볼만한 것
	- Docker 이미지 배포시 완성된 이미지로 만들어야 한다. Pod에 올린뒤 추가 설정이 어렵다고 한다.
	- 마스터 관리 - 네트웍을 빵빵하게 해야할 것이다, 이중화와 함께..아마..어렵다고 한다.
	- 마스터 이관하려다 DB를 날렸다는 사례가 있다.

