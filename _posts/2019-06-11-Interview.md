---
layout: post
title: 19-06-11
subtitle: 
gh-repo: 
gh-badge: [star, fork, follow]
tags: [Interview]
categories : [Other]
---

1) 자바의 특징에 대해 말해보시오.

1) OOP(객체 지향 언어) 

: 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해 전체 프로그램을 완성하는 개발 기법

2) "가비지 컬렉션"에 의한 메모리 자동 관리

3) "멀티 쓰레드"를 지원한다.

4) JVM 위에서 동작하기 때문에 특정 OS에 종속적이지 않고 이식성이 좋으며, 보안성이 좋다.

5) 다양한 Open 라이브러리들이 존재한다.





2) 자바를 만든 사람에 대해 아시나요?

: "제임스 고슬링"





3) 변수란?

: "하나의 값을 저장할 수 있는 메모리 공간"





4) 객체와 클래스의 차이점에 대해 설명해 보시오.

- 클래스(Class) : 현실 세계의 객체의 속성과 동작을 추려내 필드와 메서드로 정의한 것으로 "아직 메모리가 할당되지 않은 상태"

vs

- 객체(Object) : 이 Class라는 설계도를 기반으로 실제 메모리가 잡힌 것을 의미하며 이런 객체를 조합해 전체 프로그램을 완성해

   나가는 방식을 OOP(객체지향 프로그래밍)이라고 한다.
객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
oop의 관점에서 클래스의 타입으로 선언되었을 때 ‘객체’라고 부른다.
소프트웨어 세계에 구현할 대상

인스턴스란?

실제 메모리에 할당된 객체
oop의 관점으로 객체가 메모리에 할당되어 실제 사용되는 경우를 인스턴스라고 부른다


5) 객체 지향 PG이란? 또 그 특징은?

: 현실세계의 객체를 필드와 메서드로 정의한 Class를 기반으로 실제 메모리가 잡혀 만들어진 부품과 같은 객체들을 조합해

  전체 프로그램을 완성해 나가는 개발 기법으로

특징)

- 캡슐화, 은닉화 : 외부 객체에서 구현방식은 알 수 없도록 숨기고 별도로 접근할 수 있는 getter/setter 메서드를 통해 접근하도록 하는 방식

- 상속 : 부모 Class를 자식이 접근할 수 있도록 물려 받는 방식

- 다형성 : 부모 클래스 타입으로 해당 부모를 상속받는 여러 자식 class를 대입할 수 있는 성질

등을 들 수 있다.





6) 다형성이란?

: 서로 다른 클래스로부터 만들어진 객체지만 같은 부모의 Class 타입으로 이들을 관리할 수 있는(=대입될 수 있는) 성질





7) 자바의 메모리 영역(간단하게 설명)

1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.

    , 코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.

2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리

3. 힙(Heap) : new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.





8) 추상메서드? 추상 클래스?

- 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드

- 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기

        때문에 객체화 할 수 없다.





9) 인터페이스(Interface)란? 또 왜 사용하나?

: 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로
  정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.



왜 인터페이스를 사용하는가? 

: 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의
  메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의
  작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.

  또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를 

  상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.





10) 프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?

- 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에

    서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.

- 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의

  자원(메모리)는 프로세스 내에서 공유하게 된다.





11) 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.


 컬렉션프레임워크란?

데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것

다수의 데이터를 쉽게 처리할 수 있는 방법을 제공 하는 클래스의 집합으로 순서가있고 중복허용하는 List, 순서업고 중복 허용치않는 Set, 순서없고 키값은 중복x 발류는 중복가능한 Map으로 구성된다


String[]와 ArrayList 
 - String[] arrayObj = new String[2]; // 배열의 크기 지정--> 생성후 변경 불가
 - ArrayList<String> al = new ArrayList<String>();  // 배열과 비슷하나, 객체 생성후 몇개      의 값을 사용할 지 지정할 필요가 없다.

리스트는 인덱스로 관리하기에 순서가 있다.
중복을 허용하는 List/ 중복 허용하지 않는 Set
 - ArrayList : 중복을 허용하며 데이터가 순서대로 정렬된다.
 - HashSet : 중복을 허용하지 않으며 순서대로 정렬되지 않는다.

Map
 - Map은 iterator 기능이 없기 때문에 Map의 데이터를 가지고 있는 Set을 만들고 Set에 들    어가 있는 데이터 타입은 Map.Entry이다. (Set에 있는 값은 Map에 있는 값이 대응된다.
   --  > Map에 있는 값을 getKey( ), getValue( )로 알아낸다.)
   hashMap - 프로퍼티가 속해있다.자료구조
   
   벡터 - 싱크라나이즈, 멀티 쓰레드 사용가능, 어레이리스트는 싱글쓰레드에서 사용
   링크드리스트 - 객체를 제거나 추가가 빠르다.(검색은 느리다 연결되어 있기 때문에)
   


- Collection 인터페이스 

- List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.

ex) - ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를

옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.

    - LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만

연결하면 되기 때문에 삽입, 삭제에 유리하다.

    - Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리

Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

- Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우

  Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.

ex) - HashSet

    - TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

    



- Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.

ex) - HashMap

     - TreeMap

     - Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.

     - Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.


12) 캐시(Cache)와 세션(Session)의 공통점과 차이점은?

- 공통점 : 둘 다 사용자의 데이터를 저장한다.

- 차이점

- 캐시 : 캐시는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.

- 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.



13) Request 전송 방식에는 어떤 것들이 있는지 아시나요?

- Get 방식 : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.

- POST 방식 : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.

- DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.

- PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.





14) RESTFUL이란?

: 해당 URL만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식





15) Spring에서 DI란 무엇인지 아시나요?

: DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.

  DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 

 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, 

 Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.





16) Spring의 AOP란?

: AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하

 고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식으로

 이러한 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에

 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.





17) Filter와 Interceptor 방식의 차이?

: 





18) 디자인 패턴 아는 것?

1) 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우

 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.

2) 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는

   생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.

3) 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로

    사용됩니다.





19) MVC 패턴이란?

- Model : data 처리와 접근을 담당

- View : Client에 보여지는 화면을 담당

- Controller : Model과 View를 제어

하는 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.





20) 프로젝트 개발 순서??

대강...

1) 요구사항 분석 

기획 및 스토리 보드 작성

2) WBS(Work Breakdown Structure) 작성 : 작업 분해도로 프로젝트 범위와 최종산출물을 세부요소로 분할한 계층적 구조도

3) 논리 ERD 작성

4) 물리 ERD 작성

5) 개발

6) Testing

7) 유지보수





21) 오버로딩과 오버라이딩의 차이?

- 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식

- 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식



22) Servlet vs JSP

- Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것

- JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것



23) Wrapper Class의 사용이유를 아나요?

: 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로

 넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며

 최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.





24) DataBase에서 Index란?

: Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.





25) private, protected, public, default 제어자에 대해 설명해 보시오

- private : 같은 class 내부에서"만" 접근이 가능하다.

- public : 어디서든 자유롭게 접근이 가능하다.

- protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.

- default : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.





26) SI가 무엇을 하는 건지 알고 오셨나요?

: System Integration의 약자로 시스템 통합 사업으로 고객의 기존 전산시스템을 통합하거나 새로운 시스템을 구축하는 작업입니다.





27) SW 개발시 가장 비중을 크게 두어야 할 부분은 어디라고 생각하나요?

: Testing 부분입니다. 





28) 자바의 제네릭이란??

: 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식

참고 : https://rongscodinghistory.tistory.com/m/44?category=700579




1. CVS나 SVN에 대해서 아는대로 설명해 보시오.
형상 관리 툴 소프트웨어 버전관리 툴
cvs  사용자가 작업할 코드를 “check out”하고, 변경된 코드를 “check in” 하는 시스템입니다.
     파일 관리나 커밋 중 오류시 롤백되지않음
svn  소스에 모든 변경이 적용이 되거나, 아무것도 적용이 안 됩니다
     대부분의 기능을 완성하고 소스를 중앙 저장소에 commit, 깃과 차이첨은 개발자 개인의 버전 히스토리x
      
 

2. 64bit CPU와 32bit CPU의 OS적 관점에서의 차이를 설명해 보시오.
    32는 4기가까지 64는 4이상의 메모리를 인식하는 메모리 인식률이 다르다는것,
 

3. 프로세스와 쓰레드의 차이점에 대해서 설명해 보시오.( 메모리 구조 포함 )
프로세스 - 멀티 프로세싱을 지원하는 운영체제에서는 동시에 여러 프로그램을 실행 할 수 있다. 그때 실행 중인 프로그램에 대한 인스턴스를 프로세스라고한다. - 프로세스는 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않는다.
프로세스끼리 데이터 공유가 어렵다.
ipc 로 해야 서로 통신가능 하지만 자원 소모가 크다.(멀티쓰레드에 비해서) 컨텍스트스위칭? 이 일어난다. 오버헤드 발생 자원 소모 커

스레드 - 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세서 내의 주소 공간이나 자원들을 대부분 공유 하면서 실행된다
- 스레드는 해당 스레드를 위한 스택을 생성할 뿐 그 이외의 Code, Data, Heap영역을 공유한다.
싱크로나이즈 문제, 데드락 문제, 테스트 디버깅이 어렵다.

 

4. ‘데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오.

   응답없음같이 자원을 얻지못해 다음 처리를 하지못하는 상태(교착상태) 한정된 자원을 여러곳에서 쓸라고 할때 발생
   
   해결 방법 
   1. 시스템 재시작 
   2. 데드락 예방 - 한번에 모든 자원을 넣거나 주지않거나, 실행 전에 자원을 미리 할당
                 한개의 작원이라도 실패하면 모든 자원을 릴리즈한다.
                 자원 형태에 따라 순서를 매겨 프로세스가 리소스 요청하면 해당 순서에 따라 자원 할당
   3. 데드락 회피 - 각 프로세스에 자원을 할당하여 교착상태 발생하지않고 모든 프로세스가 완료 될수있는 안정적인 상태로 만든다.
   4. 데드락 확인 - 데드락 상태되는것은 허락, 데드락유발 프로세스 
   5. 데드락 회복 - 매 time slice 마다 프로세스를 제거함과 동시에 회수해 더이상 발생하지않게 한다.
   

5. 변수 명명법이 중요한 이유에 대해서 설명하고 예를 들어 보시오.
    변수는 가독성에 큰 영향을 주어 코드 리뷰하거나 공유할때 큰 영향을 준다.
    변수는 누가봐도 쉽게 알 수 있게 해야한다
    내가 짠 환율계산기 의 변수명도 사실 좋지않은 것 같다.
    내 코드가 환율 계산기라는걸 알면 exRate가 ExchangeRate라는 대충 알 수 있을 것이다.
    하지만 그걸 모른다면 이게 대체 뭐지? 할 것이다.
    줄이는 것도 좋지만 알아보기 쉽게 해야 할 것이다.
 

6. 자바의 JVM의 역할에 대해서 설명해 보시오.
기본적으로 자바프로그램들은 JVM위에서 동작한다. 
JVM 위에서 동작하기 위해서는 자바 바이트코드가 필요하다.
 이 자바 바이트코드는 개발자에 의해서 작성된 자바 소스코드(.java)를 자바컴파일러(javac)로 변환 된 코드(.class)를 말한다. 
  JAVA에서는 JVM이 자동으로 Memory 관리를 해주는 장점이 있다.
  JVM 위에서 동작하기 때문에 다양한 애플리케이션을 개발 할 수 있다(독립적)
 

7. 자바의 특징에 대해서 말해 보시오.
OOP : 객체지향언어로서, 프로그래밍에 필요한 데이터와 기능을 추상화하여 객체로 만들고 그 객체들간의 상호작용을 통해서 프로그램을 완성하는 개발 기법.

메모리를 관리해주는 언어, 가비지컬렉터가 관리해준다.

멀티쓰레드를 구현이 쉽다( 이미 잘 구현된 라이브러리가 많다 )

JVM 위에서 동작하기 때문에 다양한 애플리케이션을 개발 할 수 있다( 윈도우, 리눅스, 유닉스, 맥 등)

풍부한 생태계를 지원한다 ( 강력하고 검증된 오픈소스 라이브러리가 많다 )

동적로딩을 지원한다 ( 모든 클래스가 동시에 로딩되는게 아니라, 필요한 시점에 객체를 생성한다. 변경사항이 생긴 객체만 다시 컴파일하면 된다)
 

8. Linux에서 톰캣 환경설정을 잡는 것에 대해 설명해 보시오.

centos 기준

 Apache Tomcat 다운로드 및 설치
  Apache Tomcat 환경변수 등록 및 추가 설정
  Apache Tomcat 환경변수 등록 및 방화벽 설정
  Tomcat 전용 리눅스 계정 생성 후 그 계정으로 Tomcat 실행하기
   Apache Tomcat 서비스 등록 및 시작데몬 등록
   Apache Tomcat CentOS7 firewalld 인바운드 룰 적용 및 index.jsp 페이지 확인
 

9. WAS와 웹서버의 차이점은?

 웹 서버 (Web Server) - 아파치
클라이언트가 서버에 페이지 요청을 하면 요청을 받아 정적 컨텐츠(.html, .png, .css등)를 제공하는 서버

WAS (Web Application Server) - 톰캣
동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버 (DB조회, 로직처리가 요구되는 컨텐츠)
JSP,Servlet 구동 환경 제공(컨테이너)


10. Jquery와 Ajax에 대해 아는가?

Jquery
엘리먼트를 선택하는 강력한 방법과
선택된 엘리먼트들을 효율적으로 제어할 수 있는 다양한 수단을 제공하는
자바스크립트 라이브러리
제이쿼리의 소스는 <head></head> 사이에 위치 하게 됩니다

Ajax
 비동기적 자바스크립트와 xml
 Ajax를 통해 주로 주고 받는 형태가 XML이나 JSON 형태의 파일입니다.
 AJAX는 전체 페이지를 다시로드하지 않고, 백그라운드에서 데이터를 로드하고 웹 페이지에 표시에 관한 것이다.
 

11. 비동기와 동기 방식의 차이점에 대해서 말해보시오.(네트워크 동기,비동기 아님)
동기식 구조에서 A코드와 B코드가 있을 때, A코드가 모두 진행될 때 까지 B코드는 대기한다.
 
비동기는 두 코드가 있고 A코드를 비동기식으로 동작시키면, A코드에게 ‘시작해라’ 명령을 내린 뒤, B코드를 실행한다. 그리고 A코드는 수행이 완료되는대로 결과를 출력한다.

12. 개발시에 중요하다 생각하는 요소를 3가지 기술해 보시오.

직원들을 먹여 살려줄 컨텐츠, 그 컨텐츠를 개발할 수 있는 기술, 그 기술을 사용할 수 있는 사람

13. 스프링의 MVC에 대해서 설명하시오.

 

14. AOP란 무엇이고 왜 사용하는지

 AOP (Aspect Oriented Programming) - 관점 지향 프로그래밍

- 기능을 핵심 비지니스 로직과 공통 모듈로 구분하고, 핵심 로직에 영향을 미치지 않고 사이사이에 공통 모듈을 효과적으로 잘 끼워넣도록 하는 개발 방법이다.

공통 모듈(보안 인증, 로깅 같은 요소등)을 만든 후에 코드 밖에서 이 모듈을 비지니스 로직에 삽입하는 것이 바로 AOP 적인 개발이다. 코드 밖에서 설정된다는 것이 핵심이다.

조인포인트(joinPoint) - 횡단 관심 모듈의 기능이 삽입되어 동작할 수 있는 실행 가능한 특정위치

포인트컷(pointCut) - 어떤 클래스의 어느 조인포인트를 사용할 것인지를 결정하는 선택 기능

어드바이스 - 각 조인포인트에 삽입되어져 동작할 수 있는 코드

어드바이스(advise)의 종류
Before advice : 메서드 실행전에 적용되는 실행
After returning advice : 메서드가 정상적으로 실행된 후에 실행  (예외를 던지는 상황은 정상적인 상황에서 제외)
After throwing advice : 예외를 발생시킬 때 적용되는 Advice를 정의 (catch와 비슷)
Around advice : 메서드 호출 이전, 이후, 예외 발생 등 모든 시점에서 적용 가능한 Advice를 정의

인터셉터 - 인터셉터 체인 방식의 AOP 툴에서 사용하는 용어로 주로 한 개의 invoke 메소드를 가지는 어드바이스

위빙 - 포인트컷에 의해서 결정된 조인포인트에 지정된 어드바이스를 삽입하는 과정 (다른 말로 크로스컷팅)

인트로덕션 - 정적인 방식의 AOP 기술

애스팩트 - 포인트컷(어디에서) + 어드바이스(무엇을 할 것인지) + (필요에 따라 인트로덕션도 포함)

@Transactional > AOP 만약 안쓴다면 Try Catch문으로 계속 해줘야하니까..

15. ‘에자일’ 방법론에 대해서 아는가?

   협력과 피드백을 자주! 일찍! 더 잘하는 것 이다.
  그냥 큰 그림을 그리고 필요할때마다 수정하고 바꿔가는것

16. 스프링 환경설정 혼자 잡을 수 있는가? 대강 어떻게 해야하는지 설명해 보시오.

 

17. 웹서버 내부 구동 방식에 대해 설명할 수 있는가?

 https://kim-daeyong.github.io/2019-01-08-http%EC%9D%98-%ED%8A%B9%EC%A7%95/


 스프링 > 리퀘스트 > 디스팻치서블릭 > 핸들러맵핑 > 컨트롤러 > 모델앤뷰 > 뷰리솔버 > 뷰 > 리스폰스
REST >                                         > 메세지컨버터 > 리스폰스

18. 스프링 DI란?

 

19. UML 그려본 적 있는가?

 간단한 UML을 그려본 적 있다

20. Node js나 Angular JS를 사용해 본 적이 있는가?

 없다 
 
 개념은 Node.JS 는 웹브라우저에 종속적인 자바스크립트에서 외부에서 실행할 수 있는 Runtime 환경을 Chrome V8 엔진을 제공하여 여러 OS 환경에서 실행할 수 있는 환경을 제공하게 됩니다
 런타임이란 프로그래밍 언어가 구동되는 환경
 
 AngularJS 는 SPA(Single Page Application) 프레임워크 스프링같이 MVC를 지원해준다.


21. 캐시와 세션의 공통점과 차이점에 대해 말해보시오.
 세션은 사용자 정보를 서버에 저장되는 방식이다. 
 캐시는 CSS,JS,이미지파일이 사용자의 브라우저에 저장되서  같은 홈페이지에 접속하면 서버가 아닌 PC에서 불러온다
 
- 쿠키와 세션의 공통점과 차이점
    둘의 공통점은 사용자의 정보를 저장하는 것이다.
    차이점은 쿠키는 사용자의 브라우저에 저장되고 세션은 서버에 저장된다.
    쿠키는 보안에 취약하다, 세션은 사용자마다 고유의 세션ID를 지정해준다.
 

22. 디자인 패턴 아는 것들만 간략히 설명해 보시오.

 

23. DataBase에서 index관련 질문

 

24. 크롬이나 파이어폭스에서 개발도구를 사용해 디버깅을 해보았는가?

해보았다 포스트맨 같은 RestAPI툴도 써봤고 개발자도구로 입력받은 데이터들이나 상태코드를 보며 디버깅하였다.
 

25. JDBC는 무엇인가?
Java DataBase Connectivity 의 약자로서 자바 프로그램 내에서 DB와 관련된 작업을 처리할 수 있도록 도와주는 일을 한다.
데이터 베이스의 종류에 상관없이 가능하다.


26. 스프링을 사용하지 않고 MVC를 JSP에서 만들어 보았는가?
    서블릿을 이용해서 만들어봤다.
    스프링은 컨트롤러와 서비스,도메인을 이용하여 자동으로 데이터의 처리를 해주는데
    스프링을 이용하지않으면 트랙잭션관리도 해줘야하고 해서 중복되는 코드도 많고 코드가 길어질 수 밖에 없는데 스프링은 트랜잭션관리를 해줘서 너무 편하다.

27. DB 옵티마이저에 대해 아는가?

SQL을 처리하는 최저비용의 경로를 생성해주는 DBMS 내부 핵심엔진
옵티마이저가 생성한 처리경로를 실행 계획(Execution Plan)이라 함






---

 객체지향 프로그램의 특징은?
클래스 + 인스턴스, 캡슐화, 은닉화, 상속, 다형성

클래스 : 필요한 데이터를 추상화시켜, 변수와 메서드로 정의한것
인스턴스 : 클래스에서 정의한 내용을 바탕으로 실제 메모리에 할당된 것

캡슐화 : 코드를 재수정없이 재활용하는 것 (관련된 기능과 특성을 한곳에 모아서 분류해서 사용)
은닉화 : 메서드를 통해서만 접근가능, 데이터의 안정성을 보장하고 잘못된 값이 넘어오면 사전에 필터링이 가능하다
상속 : 부모 클래스의 속성과 기능을 그대로 이어받아서 사용할수 있고, 필요한 경우 기능을 다시 재정의해서 사용도가능
다형성 : 하나의 변수명, 함수명등이 상황에 따라 다르게 사용될 수 있다, 즉 오버로딩 오버라이딩이 가능하다.
오버라이딩 : 부모클래스의 메서드와 같은이름, 매개변수를 재정의하는 것
오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 해서 매개변수에 따라 다르게 호출할 수 있게 하는것
장점
코드 재사용이 용이하다
유지보수가 쉽다
대형프로젝트에 적합하다
단점
처리속도가 느리다
객체가 많을 경우 용량이 커질 수 있다
설계시 많은 시간과 노력이 필요하다
5) 자바의 메모리 영역
메소드 영역 : 필드 부분에서 선언된 변수(전역 변수)와 각 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메소드 static 변수, 메서드의 바이트 코드등을 보관한다. jvm이 종료될 때까지 메모리에 남아있다. 그렇기 때문에 전역변수를 많이 사용하면 메모리에 악영향을 끼칠 수 있다
스택 영역 : 지역변수( 기본 자료형 등)의 데이터값이 저장되는 공간이 stack 영역이다. stack 영역은 LIFO의 구조를 갖고, 새로운 데이터가 할당될 경우 이전 데이터는 지워진다.
힙 영역 : 인스턴스, 배열등이 headp 영역에 저장된다. Heap 영역의 메모리 참조값을 가지고 있다. 메모리가 부족해지면 GC가 Heap 영역에 있는 쓸모없는 데이터를 Young( eden, survive1,2 ), Old 영역에서 정리한다.
6) 추상클래스, 메소드란?
추상 메서드 : 메서드가 정의는 되어있으나, 내부가 구현되지 않은 메서드
추상 클래스 : 추상메소드를 적어도 하나 이상, 가지고 있는 클래스로 자식 클래스에서 오버라이딩이 필요한 추상메서드를 가지고 있기 때문에 객체화 할 수 없다
7) 인터페이스란?
추상 메서드로(선언만 되어있는 메소드) 만 이루어져 있으며, 자동으로 static final이 붙는다. 인터페이스를 구현할 클래스에서 implements라는 키워드를 사용해야 한다.

왜 사용하는가? 협업에 적합하다. 인터페이스는 구현을 하지 않아도 어떤 값을 리턴할 것인지 알기 때문에 협업시에 구현과 동시에, 구현에 따른 결과값에 따른 부가작업을 동시에 진행할 수 있다. 또한 해당 객체가 수정되어도, 개발 코드 부분을 수정하지 않고 구현한 클래스에서만 수정하면 된다.

8-1) 프로세스, 쓰레드의 차이점
프로세스란?

프로세스는 실행된 프로그램의 인스턴스이다( OS로부터 메모리를 할당받은 독립적인 객체 ).
특징
프로세스는 하나의 독립적인 메모리 공간을 가지고 있다.
기본적으로 프로세스는 하나의 쓰레드를 가지고 있다.
각 프로세스는 별도의 주소공간( 메모리 주소 )에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
그럼 다른 프로세스에 접근할려면? IPC 통신을 사용해야한다 EX) 파이프, 파일, 소켓 등등
스레드란?

쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 동작하는 작업 단위이다.
프로세스가 할당받은 자원을 사용하는 실행의 단위 ( 실제로 일을 할당받아 처리하는 일꾼과 비슷하다 )
특징
스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
프로세스와 다르게 스레드는 같은 힙공간을 공유한다 ( 스레드는 각각 별도의 Stack과 주소를 가지고 있지만 힙영역은 공유가 가능하다. )
한 스레드가, 프로세스 자원을 변경하면 다른 이웃스레드도 그 변경결과를 즉시 볼 수 있다.
8-2) 멀티프로세스, 멀티 스레드의 차이</b>
멀티프로세스란?

하나의 프로그램을 여러개의 프로세스로 구성하여, 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.

장점
여러 개의 자식 프로세스 중 하나에 문제가 발생하면, 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
단점
Context Switching에서의 오버헤드가 발생 ( 캐쉬 메모리 초기화 등 ) 무거운 작업을 실행하는 동안 많은 시간이 소요된다.
프로세스는 각각 독립된 메모리 영역을 할당받아서 공유할려면 IPC 통신을 사용해야 한다. ( 통신이 어려움 )




멀티스레드란?

하나의 프로그램을 여러개의 스레드로 처리하는것. 윈도우, 리눅스 등 많은 OS가 멀티프로세싱을 지원하고 있지만, 멀티스레딩을 기본으로 하고 있다.
웹 서버, 소켓통신 대표적인 멀티스레드의 대표적인 예이다.

장점
시스템 자원소모감소
프로세스를 여러개 생성하는 것보다 자원을 효율적으로 관리가능
시스템 처리량 증가 ( 처리 비용 감소)
스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
각각 스레드간의 작업량이 작아 Context Switching이 빠르다.
단점
데이터 동기화 문제
데드락이 걸리지 않게 주의
전체 프로세스에 영향을 준다.
테스트, 디버깅이 어렵다.
멀티스레드를 더 많이 사용하는 이유는?

프로세스에 비해서 데이터 공유가 쉬움 ( 프로세는 IPC 통신을 이용해야함. )
Context Swithing이 프로세스가 더 빈번하게 일어남 ( 자원소모가 크다 )
9) POJO란?


pojo 특정 기술에 종속되지않는 객체
POJO = Java Beans
순수하게 setter, getter 메소드로 이루어진 Value Object성의 Bean을 말한다.

클래스 상속을 강제하지 않는다. 
인터페이스 구현을 강제하지 않는다. 
애노테이션 사용을 강제하지 않는다.

라이브러리나 프레임워크로부터 강제받지 않는 객체라는 것이다. 


Plain Old Java Object의 약자로, 간단한 자바오브젝트라는 뜻이다. 특징
특정규약에 종속되지 않는다 ( 특정 어플리케이션이나, 클래스를 상속해서 만들면 안된다 )
특정환경에 종속되지 않는다 ( 환경에 독립적이다 )

POJO란 환경과 기술에 종속되지 않고, 객체지향적인 원리에 충실하게 설계된 자바오브젝트를 뜻한다.
10) 컬렉션 프레임워크란?
자바에서 컬렉션 프레임워크란, 다수의 데이터를 쉽고 효과적으로 처리할 수 있도록 표준화된 방법을 제공하는 클래스의 집합을 의미합니다. 즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구현화하여 클래스로 구현한 것입니다.
컬렉션 프레임워크의 주요 인터페이스

List, Set, Map
상속관계
Collection
List
ArrayList, Vector, LinkedList
Set
HashSet, TreeSet
Map
HashMap, Hashtable,TreeMap,Properties
컬렉션 클래스

컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스를 컬렉션 클래스라고 합니다. 컬렉션 프레임워크의 모든 클래스는 List,Set,Map 인터페이스중 하나의 인터페이스를 구현하고 있습니다.


11) 제네릭이란?


- 제네릭 설명, 왜 어디서 사용?

제네릭은 클래스에서 사용할 타입을 클래스 외부에서 설정하는 것 이라고 합니다.
제네릭 선언은  클래스<사용할 타입>

제네릭이란 사용자가 전달하는 "형식" 을 매개 변수로 사용하여 형식 내부에서 형식 매개 변수로 정의된(주로 단일 형식 매개 변수에서는 T를 사용합니다) 형식을 교체하는 것입니다.

제네릭을 사용하면 클래스 내부에서 사용하는 데이터의 타입을 지정할 수 있고,

타입을 잘못 사용하여 발생하는 에러를 최소화 할 수 있습니다.

제네릭의 타입으로는 참조형 데이터 타입만 설정 가능합니다.

이때 int같은 기본형 데이터타입을 쓰고싶을때 사용하는 것을 래퍼클래스 (wrapper class) 라고 부릅니다.

래퍼클래스는 기본형 데이터 타입 (primitive type) 을 참조형 데이터 타입으로 바꿔주는 클래스 입니다.

기본형 예 - int 
래퍼클래스(참조형) - Integer

자바 5 버전부터 제공
제네릭을 통해 버그를 줄일 수 있고 추상화
타입을 파라미터로 사용하는 것
컴파일할떄 타입체크를 한다. 런타임 체크
캐스팅을 없앤다. 그래서 타입변환없이 값을 꺼낼 수 있기에 속도면으로 좋아짐.
jdk 1.7 부터는 다이아몬드연산자만 넣으면 할 수있다. 자동으로 제네릭 타입을 유추해준다.

자바에서 제네릭이란 데이터의 타입을 일반화한다는 것을 의미합니다. 제네릭은 클래스나 메소드에서 사용할 내부 데이터타입을 컴파일 시에 미리 지정하는 방법입니다. 이렇게 컴파일 시에 미리 타입검사를 수행하면 여러가지 장점이 있습니다.

컴파일시 강한 타입체크를 할 수 있다. 자바컴파일러는 잘못 사용된 타입 때문에 발생한 문제점을 제거하기 위해 제네릭 코드에 대해 강한 타입체크를 한다. 실행 시 타입 에러가 나는 것보다는 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지하는 편이 좋다.

타입변환을 제거한다. 비제네릭 코드는 불필요한 타입 변환을 하기 때문에 프로그램 성능에 악영향을 끼친다. 분명히 String 타입으로 저장했지만 요소의 값을 찾아올 때는 반드시 형변환을 거쳐서 가져와야 한다. 결국 제네릭 타입을 사용하면 타입변환을 할 필요가 없어서 프로그램 성능이 향상된다.

JDK 1.5 이전에는 대부분의 클래스나 메소드에서 인수나 반환값으로 Object를 사용했고, 이 경우에 Object를 다시 원하는 값으로 변경하는 작업이 필요했고 이때 오류가 발생할 가능성도 존재했습니다.

JDK 1.7부터는 다이아몬드 연산자를 통해서 조금더 간단하게 작성할 수 있게 되었다.


  Product<Tv,String> product = new Product<Tv,String>();

  // 1.7부터는 선언된 제네릭 타입을 유추해서 자동으로 설정해준다.
  Product<Tv,String> product = new Product<>();


    
12) 쿠키와 세션의 공통점과 차이점은?
캐시는 클라이언트에 저장되고, 4KB 작은 값만 가질 수 있습니다. 또한 서버와 통신시 html head라인을 통해 전달되며, 중간에 쿠키가 탈취될수 있으므로 보안에 취약한 점을 가지고 있다.

세션은 서버에 저장되고, 브라우저 단위로 관리된다. 쿠키에 비해서 큰 용량을 저장할 수 있으나, 상대적으로 서버에 저장하기 때문에 이용자가 많을경우 쿠키에 비해서 부담될 수 있다.

예를 들면, spring security는 로그인에 성공하면 내부에 인메모리 방식으로 세션을 저장하고 세션의 키값을 쿠키에 저장해서 다시 리턴해준다. 그럼 로그인이 된 상태에서 네트워크에 요청을 보낼 경우 쿠키에 있는 키값을 통해서 현재 사용자의 유효여부를 판단하고 일치하면 OK, 실패하면 응답코드에 따른 처리를 한다.

현재는 Redis 같은 세션 서버를 운영하는 곳도 많다.

13) RESTFUL API란?
URI는 자원을 표현하는데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API 설계하는 중심 규칙입니다.
주요 메소드는 POST, GET, DELETE, PUT이 있습니다.




14) Java 디자인 패턴

팩토리(factory)란 ?

- 상위 클래스와 자식 클래스가 있을 때, 팩토리 클래스를 사용하여 자식 클래스의 인스턴스를 생성하는 패턴

- 객체 생성을 처리하는 클래스

- 팩토리를 사용했을 때의 장점

1. 객체 생성코드를 전부 한 객체 또는 메소드에 집어넣으면 코드에서 중복되는 내용을 제거할 수 있다.

2. 클라이언트 입장에서는 객체 인스턴스를 만들 때 필요한 구상 클래스가 아닌 인터페이스만 필요로 하게 된다.

3. 구현이 아닌 인터페이스를 바탕으로 프로그래밍을 할 수 있고, 그 결과 유연성과 확장성이 뛰어난 코드를 만들 수 있다.


팩토리 메소드 패턴

팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하게 만든다. 팩토리 메소드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브 클래스에게 맡기는 것이 된다.

추상 팩토리 패턴

추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다.


템플릿 메소드

메소드에서 알고리즘의 골격을 정의한다.

알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있다.

템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 서브클래스에서 특정 단계를 재정의 할 수 있다.

중복부분은 슈퍼클래스에 넣어두고 세부부분만 클래스에서 정의해준다.




싱글턴 - 전역변수를 사용하지않고 객체를 메모리에 단 한번만 올려 사용하는 패턴 

-클래스 내에서 인스턴스가 단 하나뿐임을 보장하므로, 프로그램 전역에서 해당 클래스의 인스턴스를 바로 얻을 수 있고, 

new 생성자로 계속 만들필요가 없어서 불필요한 메모리 낭비를 최소화한다.

DBCP에서 많이 사용, 캐시, 대화상자, 레지스트리에 많이 사용, 두번째 호출부터 로딩 빠르다

여러 곳에서 쓰니 동기화 처리하지않으면 계속 생성된다.

싱글톤에 기능을 너무 많이 넣으면 결합도가 높아져 OOP에 맞지않는다.



싱글톤 패턴

전역변수를 사용하지 않고, 객체를 하나만 생성하도록 하며 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴
싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴 ( 동일 인스턴스를 어디서나 사용한다 )

장점
new 생성자로 계속 인스턴스를 만들 필요가 없다. ( 메모리가 효율적이다 )
싱글톤으로 만들어진 인스턴스는 전역변수이기 때문에 데이터 공유가 쉽다 ex) DBCP에서 많이 사용한다
EX) 쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정 등등
인스턴스가 절대적으로 1개만 존재하는 것을 보증하고 싶을 경우에도 사용
두 번째부터 객체 로딩시간이 현저하게 줄어든다.
주의점
수정, 테스트가 어려워 문제점을 찾기 어려움.
멀티쓰레드 환경에서 동기화 처리를 하지 않으면 인스턴스가 두개가 생성이 될 수도 있음.
싱글톤 패턴이 너무 많은 일을 수행하면 OOP의 원칙에 위배된다. ( 결합도가 너무 높아진다 )



팩토리 메소드 패턴

객체 생성을 처리하는 클래스를 서브 클래스에 위임하는 패턴.

장점

객체의 생성코드를 별도의 클래스 / 메서드로 분리함으로써, 객체 생성의 변화에 대비하는데 유용하다
특정 기능의 구현은 개별클래스를 통해 제공되는 것이 바람직한 설계다 ( 결합도를 낮추기 위함 )
객체 생성을 전담하는 별도의 Factory 클래스를 이용한다
상속을 통해 하위 클래스에서 적합한 클래스의 객체를 생성한다.


템플릿 메소드 패턴

상위 클래스의 공통적인 로직은 템플릿 메소드를 두고, 메소드 내용중 세부적인 기능에 대한 정의는 추상메소드로 남겨놓으면, 자식 클래스에서 세부 기능을 구현해서 템플릿을 완성하는 패턴이다.

장점

즉 전체적으로는 비슷하지만, 세부적으로 내용이 다른 클래스가 있을 때 코드 중복을 최소화 하기에 적합하다.
ex) 소시지빵, 참치빵 ( 주요 패티만 다르고 빵과 양상추는 동일하게 들어간다 )
조금 더 자세히 설명하면 공통기능은 상위 클래스에서 정의하고 확장 or 변화가 필요한 부분만 서브 클래스에서 구현하는 것이다.


